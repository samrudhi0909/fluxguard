package main

import (
	"context"
	"log"
	"net"

	// IMPORT YOUR MODULES
	// (Check your go.mod file if these show red lines!)
	pb "fluxguard/api"
	"fluxguard/internal/limiter"

	"github.com/redis/go-redis/v9"
	"google.golang.org/grpc"
)

// 1. Server Struct
// This struct implements the "RateLimiterServer" interface generated by Protobuf
type server struct {
	pb.UnimplementedRateLimiterServer
	limiter *limiter.RateLimiterService
}

// 2. The Method Implementation
// This is the function that actually gets called when a user hits the API
func (s *server) ShouldAllow(ctx context.Context, req *pb.Request) (*pb.Response, error) {
	// Call our business logic (The "Brain")
	allowed, err := s.limiter.Allow(ctx, req.UserId, req.Capacity, req.RefillRate)
	if err != nil {
		log.Printf("Internal Error: %v", err)
		// Remember: Fail-Open! If we error, let them in.
		return &pb.Response{Allowed: true}, nil 
	}

	return &pb.Response{Allowed: allowed}, nil
}

func main() {
	// A. Setup Redis Connection
	rdb := redis.NewClient(&redis.Options{
		Addr: "localhost:6379",
	})

	// Test connection
	_, err := rdb.Ping(context.Background()).Result()
	if err != nil {
		log.Fatalf("Failed to connect to Redis: %v", err)
	}
	log.Println("Connected to Redis")

	// B. Initialize our Logic
	rateLimiterService := limiter.NewRateLimiter(rdb)

	// C. Start TCP Listener (Port 50051 is standard for gRPC)
	// OLD: lis, err := net.Listen("tcp", ":50051")
	// NEW:
	lis, err := net.Listen("tcp", "0.0.0.0:50051")
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	// D. Create and Register gRPC Server
	grpcServer := grpc.NewServer()
	pb.RegisterRateLimiterServer(grpcServer, &server{
		limiter: rateLimiterService,
	})

	log.Printf("FluxGuard gRPC Server listening on :50051")
	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}